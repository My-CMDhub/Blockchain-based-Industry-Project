<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merchant Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/boxicons@2.0.7/css/boxicons.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --success-color: #059669;
            --danger-color: #dc2626;
            --warning-color: #d97706;
            --info-color: #0891b2;
            --background-color: #f8fafc;
            --card-bg: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-color: #e5e7eb;
        }
        
        body {
            background-color: var(--background-color);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        .dashboard-container {
            padding: 2rem;
        }

        .stats-card {
            background: var(--card-bg);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease-in-out;
            border: 1px solid var(--border-color);
        }

        .stats-card:hover {
            transform: translateY(-2px);
        }

        .stats-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .stats-label {
            color: var(--text-secondary);
            font-size: 0.9rem; 
            margin-top: 0.5rem;
        }

        .transaction-table {
            background: var(--card-bg);
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .transaction-table th {
            background: var(--background-color);
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            padding: 1rem;
        }

        .transaction-table td {
            padding: 1rem;
            vertical-align: middle;
        }

        .status-badge {
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .status-pending {
            background: rgba(217, 119, 6, 0.1);
            color: var(--warning-color);
        }

        .status-confirmed {
            background: rgba(5, 150, 105, 0.1);
            color: var(--success-color);
        }

        .status-failed {
            background: rgba(220, 38, 38, 0.1);
            color: var(--danger-color);
        }

        .status-warning {
            background: rgba(234, 179, 8, 0.1);
            color: var(--warning-color);
        }

        .unverified-row {
            background-color: rgba(234, 179, 8, 0.05);
        }

        .wrong-payment-row {
            background-color: rgba(220, 38, 38, 0.08);
        }

        .wrong-payment-details {
            background-color: rgba(220, 38, 38, 0.05);
            border-left: 4px solid #dc2626;
            padding: 0.5rem 1rem;
            margin-top: 0.5rem;
        }

        .wrong-payment-tag {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background-color: rgba(220, 38, 38, 0.1);
            color: #dc2626;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .action-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
        }

        .action-button-primary {
            background: var(--primary-color);
            color: white;
            border: none;
        }
        
        .action-button-primary:hover {
            background: var(--secondary-color);
        }

        .action-button-outline {
            background: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }
        
        .action-button-outline:hover {
            background: var(--primary-color);
            color: white;
        }
        
        .address-card {
            background: var(--card-bg);
            border-radius: 1rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
        }

        .address-card .address {
            font-family: monospace;
                font-size: 0.9rem;
            word-break: break-all;
        }

        .copy-button {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            border-radius: 0.25rem;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
        }

        .copy-button:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            background: var(--card-bg);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: none;
        }

        .toast.success {
            border-left: 4px solid var(--success-color);
        }

        .toast.error {
            border-left: 4px solid var(--danger-color);
        }

        .toast.warning {
            border-left: 4px solid var(--warning-color);
        }

        @media (max-width: 768px) {
            .dashboard-container {
                padding: 1rem;
            }

            .stats-card {
            margin-bottom: 1rem;
            }

            .transaction-table {
                font-size: 0.9rem;
            }
        }

        .action-button-danger {
            background: var(--danger-color);
            color: white;
            border: none;
        }

        .action-button-danger:hover {
            background: #b91c1c;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="row mb-4">
            <div class="col-12">
                <h1 class="mb-4">Merchant Dashboard</h1>
            </div>
        </div>
        
        <div class="row mb-4">
            <div class="col-md-4 mb-3">
                <div class="stats-card">
                    <div class="stats-value" id="totalBalance">0.00 ETH</div>
                    <div class="stats-label">Total Balance</div>
            </div>
                    </div>
            <div class="col-md-4 mb-3">
                <div class="stats-card">
                    <div class="stats-value" id="pendingBalance">0.00 ETH</div>
                    <div class="stats-label">Pending Balance</div>
                </div>
                                </div>
            <div class="col-md-4 mb-3">
                <div class="stats-card">
                    <div class="stats-value" id="confirmedBalance">0.00 ETH</div>
                    <div class="stats-label">Confirmed Balance</div>
                        </div>
                                    </div>
                                </div>

        <div class="row mb-4">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title mb-4">Release Funds</h5>
                        <div class="mb-3">
                            <label for="releaseAmount" class="form-label">Amount (ETH)</label>
                            <input type="number" class="form-control" id="releaseAmount" step="0.001" min="0">
                            </div>
                        <div class="d-flex gap-2">
                            <button class="action-button action-button-primary" onclick="releaseFunds()">Release Specified Amount</button>
                            <button class="action-button action-button-outline" onclick="releaseAllFunds()">Release All Funds</button>
                        </div>
                    </div>
                            </div>
                        </div>
            <div class="col-md-4">
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title mb-4">Network Info</h5>
                        <p class="mb-2">Network: <span id="networkName">-</span></p>
                        <p class="mb-2">Chain ID: <span id="chainId">-</span></p>
                        <p class="mb-0">Merchant Address: <span id="merchantAddress" class="text-break">-</span></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wrong Payments Monitor -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card border-danger">
                    <div class="card-body">
                        <h5 class="card-title mb-3 text-danger">Wrong Payments Monitor</h5>
                        <div class="d-flex justify-content-between">
                            <div>
                                <small class="text-muted">Count</small>
                                <h4 id="wrongPaymentsCount">0</h4>
                            </div>
                            <div>
                                <small class="text-muted">Amount</small>
                                <h4 id="wrongPaymentsAmount">0.00</h4>
                            </div>
                            <div>
                                <small class="text-muted">Action</small>
                                <div>
                                    <button class="btn btn-sm btn-outline-danger" onclick="showWrongPaymentsHelp()">
                                        <i class="bx bx-help-circle me-1"></i> Help
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger" onclick="showWrongPaymentsList()">
                                        <i class="bx bx-list-ul me-1"></i> Details
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row mb-4">
            <div class="col-12">
        <div class="card">
            <div class="card-body">
                        <h5 class="card-title mb-4">Active Payment Addresses</h5>
                        <div id="activeAddresses">
                            <p class="text-muted">No active addresses found.</p>
                </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div id="paymentAlerts" class="mb-4">
                    <div id="wrongPaymentsNotice" style="display: none;"></div>
                    <div id="unverifiedPaymentsNotice" style="display: none;"></div>
                </div>
        <div class="card">
            <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-4">
                            <h5 class="card-title mb-0">Transaction History</h5>
                            <div>
                                <button class="btn btn-sm btn-outline-primary me-2" onclick="verifyAllTransactions()">
                                    <i class="bx bx-check-shield"></i> Verify All
                                </button>
                                <button class="btn btn-sm btn-outline-secondary" onclick="refreshTransactionHistory(true, true)">
                                    <i class="bx bx-refresh"></i> Refresh
                                </button>
                            </div>
                        </div>
                        <div class="table-responsive transaction-table">
                            <table class="table table-hover mb-0">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Type</th>
                                        <th>Amount</th>
                                    <th>Status</th>
                                        <th>Transaction</th>
                                </tr>
                            </thead>
                            <tbody id="transactionHistory">
                                    <tr>
                                        <td colspan="5" class="text-center">Loading transactions...</td>
                                    </tr>
                            </tbody>
                        </table>
                    </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Unverified Payments Card -->
        <div class="col-xl-3 col-md-6">
            <div class="card balance-card mb-4">
                <div class="card-body">
                    <h5 class="card-title">Unverified Payments</h5>
                    <div class="d-flex align-items-center mb-2">
                        <i class='bx bx-time-five me-2 balance-icon'></i>
                        <span id="unverifiedCount" class="balance-value">
                            <div class="spinner-border spinner-border-sm text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </span>
                    </div>
                    <h6 class="text-muted">Amount</h6>
                    <div class="d-flex align-items-center">
                        <i class='bx bx-money me-2 balance-icon'></i>
                        <span id="unverifiedAmount" class="balance-value">
                            <div class="spinner-border spinner-border-sm text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </span>
                    </div>
                    <small class="text-muted mt-2 d-block">Last updated: <span class="last-updated">-</span></small>
                </div>
            </div>
        </div>
    </div>

    <!-- Add a more visible toast container -->
    <div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 1050;">
        <div id="toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header">
                <i id="toastIcon" class="bx me-2"></i>
                <strong id="toastTitle" class="me-auto">Notification</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div id="toastContent" class="toast-body">
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    <script>
        // Initialize Web3 instance
        let web3;
        try {
            // Initialize Web3 with a fallback provider
            web3 = new Web3(new Web3.providers.HttpProvider('https://sepolia.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161'));
            console.log('Web3 initialized successfully with chain ID:', web3.eth.getChainId);
        } catch (error) {
            console.error('Failed to initialize web3:', error);
            // Fallback to a minimal web3 instance that can at least handle utils functions
            web3 = new Web3();
        }
        
        // Check if web3 utils are available
        if (!web3.utils) {
            console.error('Web3 utils not available - some functionality may be limited');
        }
        
        // Cache for balance data to avoid unnecessary fetches
        let balanceCache = null;
        let balanceCacheTime = 0;
        const BALANCE_CACHE_DURATION = 30000; // 30 seconds

        // Cache for transaction data
        let transactionCache = null;
        let transactionCacheTime = 0;
        const TRANSACTION_CACHE_DURATION = 30000; // 30 seconds
        
        // API Key - hardcoded to match the server's expected key from .env file
        const API_KEY = "ef2d127de37b942baad06145e54b0c619a1f22f95b608e65f3c6b1a7a59dfc47";
        
        // Debug helper to intercept and log all fetch requests
        const originalFetch = window.fetch;
        window.fetch = async function(url, options = {}) {
            // Log the request details
            const requestId = Math.random().toString(36).substring(2, 8);
            const requestInfo = {
                id: requestId,
                url,
                method: options.method || 'GET',
                headers: options.headers || {},
                body: options.body ? JSON.parse(options.body) : undefined
            };
            
            console.group(`Fetch Request [${requestId}]: ${requestInfo.method} ${url}`);
            console.log('Request details:', requestInfo);
            console.groupEnd();
            
            try {
                // Make the actual request
                const response = await originalFetch(url, options);
                
                // Clone the response so we can read it multiple times
                const clonedResponse = response.clone();
                
                // Try to get the response body as text
                let responseBody;
                try {
                    responseBody = await clonedResponse.text();
                    
                    // Try to parse as JSON if possible
                    try {
                        responseBody = JSON.parse(responseBody);
                    } catch (e) {
                        // Not JSON, keep as text
                    }
                } catch (e) {
                    responseBody = 'Unable to read response body';
                }
                
                // Log the response
                console.group(`Fetch Response [${requestId}]: ${response.status} ${response.statusText}`);
                console.log('Response details:', {
                    status: response.status,
                    statusText: response.statusText,
                    headers: Array.from(response.headers.entries()),
                    body: responseBody
                });
                console.groupEnd();
                
                return response;
            } catch (error) {
                console.group(`Fetch Error [${requestId}]`);
                console.error('Fetch failed:', error);
                console.groupEnd();
                throw error;
            }
        };
        
        // Helper function to make authenticated API requests
        async function fetchWithAuth(url, options = {}) {
            try {
                // Log key info for debugging (partial key only)
                console.log(`Using API key: ${API_KEY.substring(0, 8)}...${API_KEY.substring(API_KEY.length - 8)} for request to ${url}`);
                
                // Merge headers, ensuring X-API-Key is included
                const headers = {
                    'Content-Type': 'application/json',
                    'X-API-Key': API_KEY,
                    ...(options.headers || {})
                };
                
                // Return fetch with merged options
                return fetch(url, {
                    ...options,
                    headers
                });
            } catch (error) {
                console.error('Error in fetchWithAuth:', error);
                throw new Error(`Authentication error: ${error.message}`);
            }
        }

        // Format ETH value consistently - improved version
        function formatETHValue(value) {
            // Handle potential null, undefined, or invalid values
            if (!value && value !== 0) {
                return '0.000000';
            }
            
            try {
                // Handle BigInt or large number strings that might be in Wei
                if (typeof value === 'bigint' || (typeof value === 'string' && !value.includes('.') && value.length > 10)) {
                    // Convert from Wei to ETH
                    const valueInEth = Number(value) / 1e18;
                    return valueInEth.toFixed(6);
                }
                
                // Check if the value is already a decimal string (e.g. "0.125")
                if (typeof value === 'string' && value.includes('.')) {
                    // Already in ETH format, just format it
                    const floatValue = parseFloat(value);
                    if (isNaN(floatValue)) return '0.000000';
                    return floatValue.toFixed(6);
                }
                
                // Check if web3.utils is available for conversion
                if (web3 && web3.utils && web3.utils.fromWei && value.toString().length > 10) {
                    try {
                        // Convert wei to ETH (handles string or number inputs)
                        const valueStr = value.toString();
                        const ethValue = web3.utils.fromWei(valueStr, 'ether');
                        const ethFloat = parseFloat(ethValue);
                        return ethFloat.toFixed(6);
                    } catch (web3Error) {
                        console.warn('Error using web3.utils.fromWei, falling back to manual conversion:', web3Error);
                        // Fallback to manual conversion
                        const numValue = Number(value) / 1e18;
                        if (isNaN(numValue)) return '0.000000';
                        return numValue.toFixed(6);
                    }
                } else {
                    // For regular numbers or small strings, format directly
                    const numValue = Number(value);
                    return numValue.toFixed(6);
                }
            } catch (error) {
                console.error('Error formatting ETH value:', error, value);
                // Last resort fallback
                return '0.000000';
            }
        }

        // Safely convert any balance format to ETH
        function safeToEth(balance) {
            if (!balance && balance !== 0) return 0;
            
            try {
                // If it's already in ETH format (decimal string)
                if (typeof balance === 'string' && balance.includes('.')) {
                    return parseFloat(balance);
                }
                
                // Handle large numbers that are likely in Wei
                if (typeof balance === 'string' && !balance.includes('.') && balance.length > 10) {
                    return Number(balance) / 1e18;
                }
                
                // Check if web3.utils is available
                if (!web3 || !web3.utils || !web3.utils.fromWei) {
                    console.warn('web3.utils not available, using manual conversion');
                    return Number(balance) / 1e18;
                }
                
                try {
                    // Convert from wei using web3.utils
                    const balanceStr = balance.toString();
                    return parseFloat(web3.utils.fromWei(balanceStr, 'ether'));
                } catch (web3Error) {
                    console.warn('Error using web3.utils.fromWei in safeToEth:', web3Error);
                    // Fallback method
                    return Number(balance) / 1e18;
                }
            } catch (error) {
                console.error('Error converting balance to ETH:', error, balance);
                // Default fallback
                return 0;
            }
        }

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing merchant dashboard...');
            
            // Log API key info for debugging (partial key)
            console.log(`Using API key: ${API_KEY.substring(0, 8)}...${API_KEY.substring(API_KEY.length - 8)}`);
            
            // Initial data load
            try {
                refreshBalance(true);
                refreshTransactionHistory(true);
                loadMerchantConfig();
                
                // Set up auto-refresh with error handling
                setInterval(() => {
                    try {
                        refreshBalance();
                    } catch (error) {
                        console.error('Auto-refresh balance error:', error);
                    }
                }, 30000);
                
                setInterval(() => {
                    try {
                        refreshTransactionHistory();
                    } catch (error) {
                        console.error('Auto-refresh transactions error:', error);
                    }
                }, 30000);
                
                console.log('Dashboard initialized successfully');
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                showToast('Error initializing dashboard: ' + error.message, 'error');
            }
        });

        // Load merchant configuration
        function loadMerchantConfig() {
            fetch('/api/config')
                .then(response => response.json())
                .then(config => {
                    if (config.merchantAddress) {
                        document.getElementById('merchantAddress').textContent = config.merchantAddress;
                    }
                    if (config.networkName) {
                        document.getElementById('networkName').textContent = config.networkName;
                    }
                    if (config.chainId) {
                        document.getElementById('chainId').textContent = config.chainId;
                    }
                })
                .catch(err => {
                    console.error('Failed to load merchant config:', err);
                    showToast('Failed to load merchant configuration', 'error');
                });
        }

        // Refresh wallet balance
        async function refreshBalance(forceRefresh = false) {
            const now = Date.now();
            if (!forceRefresh && balanceCache && (now - balanceCacheTime < BALANCE_CACHE_DURATION)) {
                updateBalanceDisplay(balanceCache);
                return;
            }
            
            try {
                // Show loading state for balances
                showLoadingForBalances();
                
                console.log('Fetching wallet balance...');
                
                // Make sure API key is properly set
                if (!API_KEY) {
                    throw new Error('API key is not configured');
                }
                
                // Attempt to fetch with proper error handling
                let response;
                try {
                    response = await fetchWithAuth('/api/wallet-balance');
                } catch (fetchError) {
                    console.error('Network error fetching balance:', fetchError);
                    
                    // If we have cached data, use it as fallback and show warning
                    if (balanceCache) {
                        updateBalanceDisplay(balanceCache);
                        hideLoadingForBalances(); 
                        showToast('Using cached balance due to network error', 'warning');
                        return;
                    }
                    
                    throw new Error(`Network error: ${fetchError.message}`);
                }
                
                // Check for HTTP errors
                if (!response.ok) {
                    console.error(`HTTP error: ${response.status} ${response.statusText}`);
                    
                    // Try to get more error details from the response
                    let errorDetails = '';
                    try {
                        const errorData = await response.json();
                        errorDetails = errorData.error || errorData.message || '';
                        console.error('Error details:', errorData);
                        
                        // Special handling for "Merchant address not configured" error
                        if (errorDetails.includes('Merchant address not configured')) {
                            // This is a common configuration issue - show a more helpful message
                            showToast('Merchant wallet needs configuration. Please check server settings.', 'warning');
                            // Create a placeholder "dummy" data to display
                            updateBalanceDisplay({
                                totalBalance: "0",
                                pendingBalance: "0",
                                verifiedBalance: "0",
                                wrongPayments: 0,
                                wrongPaymentsAmount: "0"
                            });
                            hideLoadingForBalances();
                            return;
                        }
                    } catch (e) {
                        // Ignore parse errors
                    }
                    
                    // If we have cached data, use it as fallback and show warning
                    if (balanceCache) {
                        updateBalanceDisplay(balanceCache);
                        hideLoadingForBalances();
                        showToast(`Using cached balance. Server error: ${response.status}`, 'warning');
                        return;
                    }
                    
                    throw new Error(`Server responded with status: ${response.status}${errorDetails ? ` - ${errorDetails}` : ''}`);
                }
                
                // Parse the JSON response with error handling
                let data;
                try {
                    data = await response.json();
                } catch (parseError) {
                    console.error('Error parsing response:', parseError);
                    
                    if (balanceCache) {
                        updateBalanceDisplay(balanceCache);
                        hideLoadingForBalances();
                        showToast('Using cached balance due to invalid response format', 'warning');
                        return;
                    }
                    
                    throw new Error('Invalid response format from server');
                }
                
                console.log('Received balance data:', data);
                
                // Check if the response indicates an error
                if (data.success === false) {
                    const errorMsg = data.error || 'Unknown error fetching balance';
                    console.error('API returned error:', errorMsg);
                    
                    if (balanceCache) {
                        updateBalanceDisplay(balanceCache);
                        hideLoadingForBalances();
                        showToast(`Using cached balance. API error: ${errorMsg}`, 'warning');
                        return;
                    }
                    
                    throw new Error(errorMsg);
                }
                
                // Data validation - ensure we have minimum required data
                if (!data.totalBalance && !data.balance) {
                    console.warn('Response missing balance data:', data);
                    
                    // If it has addresses but no balance, try to calculate total from addresses
                    if (data.addressDetails || data.addresses) {
                        try {
                            let calculatedTotal = 0;
                            
                            if (data.addressDetails) {
                                for (const details of Object.values(data.addressDetails)) {
                                    if (details.rawBalance || details.balance) {
                                        calculatedTotal += safeToEth(details.rawBalance || details.balance);
                                    }
                                }
                            } else if (data.addresses) {
                                for (const addr of data.addresses) {
                                    if (addr.balance) {
                                        calculatedTotal += safeToEth(addr.balance);
                                    }
                                }
                            }
                            
                            // If we calculated a balance, use that
                            if (calculatedTotal > 0) {
                                data.totalBalance = calculatedTotal.toString();
                                console.log('Calculated total balance from addresses:', data.totalBalance);
                            }
                        } catch (calcError) {
                            console.error('Error calculating balance from addresses:', calcError);
                        }
                    }
                    
                    // If still no balance and we have cache, use cache as fallback
                    if (!data.totalBalance && !data.balance && balanceCache) {
                        updateBalanceDisplay(balanceCache);
                        hideLoadingForBalances();
                        showToast('Using cached balance due to missing data in response', 'warning');
                        return;
                    }
                    
                    // If no balance and no addressDetails/addresses, this is an error
                    if (!data.totalBalance && !data.balance && !data.addressDetails && !data.addresses) {
                        throw new Error('Response missing required balance data');
                    }
                }
                
                // Check if we have wrong payments data
                if (data.wrongPayments > 0) {
                    console.warn(`Found ${data.wrongPayments} wrong payments totaling ${data.wrongPaymentsAmount} ETH`);
                    // This will be displayed in updateBalanceDisplay
                }
                
                // Store in cache and update UI
                balanceCache = data;
                balanceCacheTime = now;
                
                updateBalanceDisplay(data);
                
                // Process address data if available
                if (data.addressDetails) {
                    const addresses = [];
                    for (const [addr, details] of Object.entries(data.addressDetails)) {
                        addresses.push({
                            address: addr,
                            balance: details.rawBalance || details.balance,
                            type: details.type
                        });
                    }
                    updateActiveAddresses(addresses);
                } else if (data.addresses) {
                    updateActiveAddresses(data.addresses);
                } else {
                    updateActiveAddresses([]);
                }
            } catch (error) {
                console.error('Failed to fetch balance:', error);
                hideLoadingForBalances(); // Make sure to hide loading indicators on error
                showToast('Failed to refresh balance: ' + error.message, 'error');
            }
        }

        // Show loading state for balances
        function showLoadingForBalances() {
            document.getElementById('totalBalance').innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span> Loading...';
            document.getElementById('pendingBalance').innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span> Loading...';
            document.getElementById('confirmedBalance').innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span> Loading...';
            
            // Also show loading for active addresses
            document.getElementById('activeAddresses').innerHTML = `
                <div class="d-flex justify-content-center my-3">
                    <div class="spinner-border spinner-border-sm text-primary me-2" role="status">
                            <span class="visually-hidden">Loading...</span>
                    </div>
                    <span>Loading addresses...</span>
                        </div>
                    `;
        }
        
        // Hide loading state for balances (only used on error, otherwise updateBalanceDisplay will replace content)
        function hideLoadingForBalances() {
            document.getElementById('totalBalance').textContent = '0.00 ETH';
            document.getElementById('pendingBalance').textContent = '0.00 ETH';
            document.getElementById('confirmedBalance').textContent = '0.00 ETH';
            
            // Reset active addresses display
            document.getElementById('activeAddresses').innerHTML = '<p class="text-muted">No active addresses found.</p>';
        }

        // Update balance display with better error handling and format detection
        function updateBalanceDisplay(data) {
            console.log("Received balance data:", data);
            
            if (!data) {
                console.error("No balance data received");
                showToast("Error updating balance display", "error");
                return;
            }
            
            // Helper function to format balance with appropriate decimal places
            function formatBalance(value) {
                if (!value && value !== 0) return "0.00";
                
                try {
                    // If value is already a decimal string (e.g., "0.030653416615012")
                    if (typeof value === 'string' && value.includes('.')) {
                        const numValue = parseFloat(value);
                        if (isNaN(numValue)) return "0.00";
                        return numValue.toFixed(6); // Always show 6 decimal places for consistency
                    }
                    
                    // Convert value to number if it's a string without decimal
                    if (typeof value === 'string' && !value.includes('.')) {
                        value = parseInt(value);
                    }
                    
                    // For big numbers (likely in Wei), convert to ETH
                    if (typeof value === 'number' && value > 1e10) {
                        value = value / 1e18;
                    }
                    
                    // Format the number
                    return value.toFixed(6); // Consistent 6 decimal places
                } catch (err) {
                    console.error("Error formatting balance:", err, value);
                    return "0.000000";
                }
            }
            
            try {
                // Update total balance
                if (data.totalBalance !== undefined) {
                    document.getElementById('totalBalance').textContent = formatBalance(data.totalBalance) + " ETH";
                }
                
                // Update pending balance
                if (data.pendingBalance !== undefined) {
                    document.getElementById('pendingBalance').textContent = formatBalance(data.pendingBalance) + " ETH";
                }
                
                // Update confirmed balance
                if (data.verifiedBalance !== undefined) {
                    document.getElementById('confirmedBalance').textContent = formatBalance(data.verifiedBalance) + " ETH";
                }
                
                // Handle wrong payments
                if (data.wrongPayments !== undefined && data.wrongPaymentsAmount !== undefined) {
                    const wrongCount = parseInt(data.wrongPayments) || 0;
                    document.getElementById('wrongPaymentsCount').textContent = wrongCount;
                    document.getElementById('wrongPaymentsAmount').textContent = formatBalance(data.wrongPaymentsAmount);
                }
                
                // Handle unverified payments
                if (data.unverifiedPayments !== undefined && data.unverifiedPaymentsAmount !== undefined) {
                    const unverifiedCount = parseInt(data.unverifiedPayments) || 0;
                    
                    // If we have unverified payments in the UI elements
                    const unverifiedCountElement = document.getElementById('unverifiedCount');
                    const unverifiedAmountElement = document.getElementById('unverifiedAmount');
                    
                    if (unverifiedCountElement) {
                        unverifiedCountElement.textContent = unverifiedCount;
                    }
                    
                    if (unverifiedAmountElement) {
                        unverifiedAmountElement.textContent = formatBalance(data.unverifiedPaymentsAmount) + " ETH";
                    }
                }
            } catch (err) {
                console.error("Error updating balance display:", err);
                showToast("Error updating balance display", "error");
            }
        }

        // Update active addresses display
        function updateActiveAddresses(addresses) {
            const container = document.getElementById('activeAddresses');
            if (!addresses || addresses.length === 0) {
                container.innerHTML = '<p class="text-muted">No active addresses found.</p>';
                return;
            }

            const addressesHtml = addresses.map(addr => {
                // Format the balance using the helper function
                const formattedBalance = formatETHValue(addr.balance);
                
                return `
                <div class="address-card">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <small class="text-muted">Address</small>
                        <button class="copy-button" onclick="copyToClipboard('${addr.address}', this)">
                            <i class="bx bx-copy"></i>
                        </button>
                    </div>
                    <div class="address mb-2">${addr.address}</div>
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">Balance</small>
                        <span>${formattedBalance} ETH</span>
                </div>
                        </div>
            `}).join('');

            container.innerHTML = addressesHtml;
        }

        // Refresh transaction history from server
        async function refreshTransactionHistory(force = false, verifyPending = false) {
            // Show loading state in transaction table
            const tbody = document.getElementById('transactionHistory');
            if (!tbody) {
                console.error('Transaction history table body not found');
                return;
            }
            
            // Only skip the fetch if we have a recent cache and force=false
            const now = Date.now();
            if (!force && transactionCache && transactionCacheTime && (now - transactionCacheTime < 30000)) {
                console.log('Using cached transaction data (< 30 seconds old)');
                // Still display the cached data
                displayTransactionHistory(transactionCache.transactions);
                updatePaymentNotices(transactionCache);
                return;
            }
            
            // Display loading state
            tbody.innerHTML = `
                <tr>
                    <td colspan="5" class="text-center">
                        <div class="d-flex justify-content-center">
                            <div class="spinner-border spinner-border-sm me-2" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            Loading transaction history...
                        </div>
                    </td>
                </tr>
            `;
            
            try {
                // Fetch the transaction history
                const response = await fetchWithAuth('/api/merchant-transactions');
                
                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('Transaction history file not found, creating it...');
                        // Create the transaction file if it doesn't exist
                        await createTransactionFileIfNeeded();
                        throw new Error('Transaction history not found - initializing new history');
                    }
                    
                    // Try to get error details from response
                    let errorDetails = '';
                    try {
                        const errorResponse = await response.json();
                        errorDetails = errorResponse.error || '';
                    } catch (e) {
                        // Ignore errors parsing the error response
                    }
                    
                    throw new Error(`Server responded with status: ${response.status}${errorDetails ? ' - ' + errorDetails : ''}`);
                }
                
                // Parse the response
                let data;
                try {
                    data = await response.json();
                } catch (parseError) {
                    console.error('Error parsing JSON response:', parseError);
                    throw new Error('Invalid response from server: not valid JSON');
                }
                
                // Log the full transaction data for debugging
                console.log('Received transaction data:', JSON.stringify(data, null, 2));
                
                // Validate data structure
                if (!data || typeof data !== 'object') {
                    throw new Error('Invalid transaction data structure');
                }
                
                // If transactions not present, create an empty array for display
                if (!data.transactions) {
                    console.warn('No transactions array in response, creating empty array');
                    data.transactions = [];
                }
                
                // Cache the data for future use
                transactionCache = data;
                transactionCacheTime = now;
                
                // Display transaction history and update notices
                displayTransactionHistory(data.transactions);
                updatePaymentNotices(data);
                
                // If requested, verify pending transactions
                if (verifyPending) {
                    verifyPendingTransactions(data.transactions);
                }
                
            } catch (error) {
                console.error('Failed to fetch transactions:', error);
                
                // Show error in transaction table
                document.getElementById('transactionHistory').innerHTML = `
                    <tr>
                        <td colspan="5" class="text-center text-danger">
                            <i class="bx bx-error-circle me-2"></i>
                            ${error.message || 'Unknown error loading transactions'}
                        </td>
                    </tr>
                `;
                
                showToast('Failed to refresh transaction history: ' + error.message, 'error');
            }
        }

        // Helper function to create transaction file if needed
        async function createTransactionFileIfNeeded() {
            try {
                console.log('Creating transaction file...');
                const response = await fetchWithAuth('/api/create-transaction-file', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    console.log('Transaction file created successfully');
                    // Refresh after a short delay
                    setTimeout(refreshTransactionHistory, 2000);
                    } else {
                    console.error('Failed to create transaction file:', await response.text());
                    }
                } catch (error) {
                console.error('Failed to create transaction file:', error);
            }
        }

        // Display transaction history in the table
        function displayTransactionHistory(transactions) {
            const tbody = document.getElementById('transactionHistory');
            if (!tbody) {
                console.error('Transaction history table body not found');
                return;
            }
            
            if (!transactions || !Array.isArray(transactions) || transactions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="text-center">No transactions found</td></tr>';
                return;
            }

            try {
                // Generate rows for each transaction
                const rows = transactions.map(tx => {
                    // Skip invalid transactions
                    if (!tx) return '';
                    
                    try {
                        // Format the amount safely
                        const formattedAmount = formatETHValue(tx.amount);
                        
                        // Extract transaction hash (handle different property names)
                        const txHash = tx.txHash || tx.hash || 'unknown';
                        
                        // Format transaction type
                        const txType = (tx.type || 'unknown').toString();
                        const formattedType = txType.charAt(0).toUpperCase() + txType.slice(1);
                        
                        // Format status
                        const txStatus = (tx.status || 'pending').toString();
                        const formattedStatus = txStatus.charAt(0).toUpperCase() + txStatus.slice(1);
                        
                        // Format date
                        let dateDisplay = 'Unknown date';
                        if (tx.timestamp) {
                            try {
                                const txDate = new Date(tx.timestamp);
                                if (!isNaN(txDate.getTime())) {
                                    dateDisplay = txDate.toLocaleString();
                                }
                            } catch (dateError) {
                                console.warn('Error formatting date:', dateError, tx.timestamp);
                            }
                        }
                        
                        // Check if this is an unverified payment
                        const isUnverified = txType === 'payment' && 
                                             txStatus !== 'confirmed' && 
                                             txStatus !== 'verified';
                                             
                        // Check if this is a wrong payment
                        const isWrongPayment = tx.isWrongPayment === true || txStatus === 'wrong' || tx.wrongPayment === true;
                        
                        // Apply css class based on payment status
                        let rowClass = isWrongPayment ? 'wrong-payment-row' : (isUnverified ? 'unverified-row' : '');
                        
                        // Add a verify button if this is an unverified payment with a transaction hash
                        let verifyButton = '';
                        if (isUnverified && txHash && txHash !== 'unknown') {
                            verifyButton = `
                                <button class="btn btn-sm btn-outline-primary ms-2" 
                                        onclick="verifyTransaction('${txHash}')" 
                                        title="Verify this transaction on the blockchain">
                                    <i class="bx bx-check-shield"></i> Verify
                                </button>
                            `;
                        }
                        
                        // Generate row HTML with appropriate status indicators
                        return `
                        <tr class="${rowClass}">
                            <td>${dateDisplay}</td>
                            <td>
                                <span class="status-badge ${txType === 'payment' ? 'status-confirmed' : 'status-pending'}">
                                    ${formattedType}
                                </span>
                            </td>
                            <td>${formattedAmount} ETH</td>
                            <td>
                                <span class="status-badge ${isWrongPayment ? 'status-failed' : getStatusClass(txStatus)}">
                                    ${isWrongPayment ? 'Wrong Address' : (isUnverified ? 'Unverified' : formattedStatus)}
                                </span>
                            </td>
                            <td>
                                ${txHash && txHash !== 'unknown' && txHash.length > 10 ? 
                                    `<a href="https://sepolia.etherscan.io/tx/${txHash}" target="_blank" class="text-decoration-none">
                                        ${txHash.substring(0, 8)}...${txHash.substring(txHash.length - 6)}
                                        <i class="bx bx-link-external ms-1"></i>
                                    </a>${verifyButton}` : 
                                    `<span class="text-muted">${tx.address ? tx.address.substring(0, 8) + '...' : 'N/A'}</span>`
                                }
                            </td>
                        </tr>
                        `;
                    } catch (rowError) {
                        console.error('Error processing transaction row:', rowError, tx);
                        return ''; // Skip this row on error
                    }
                }).filter(row => row !== ''); // Remove empty rows
                
                // Update table content
                if (rows.length > 0) {
                    tbody.innerHTML = rows.join('');
                } else {
                    tbody.innerHTML = '<tr><td colspan="5" class="text-center">No valid transactions found</td></tr>';
                }
            } catch (error) {
                console.error('Error displaying transaction history:', error);
                tbody.innerHTML = '<tr><td colspan="5" class="text-center">Error: ' + error.message + '</td></tr>';
                showToast('Error updating transaction history', 'error');
            }
        }

        // Update payment notices for unverified and wrong payments
        function updatePaymentNotices(data) {
            // Display unverified payment stats if available
            if (data.unverifiedPayments && data.unverifiedPaymentsAmount) {
                try {
                    const unverifiedCount = data.unverifiedPayments;
                    const unverifiedAmount = formatETHValue(data.unverifiedPaymentsAmount);
                    
                    if (unverifiedCount > 0) {
                        // Show unverified payment notice
                        const noticeContainer = document.getElementById('unverifiedPaymentsNotice');
                        if (noticeContainer) {
                            noticeContainer.innerHTML = `
                                <div class="alert alert-warning d-flex align-items-center" role="alert">
                                    <i class="bx bx-time me-2"></i>
                                    <div>
                                        You have ${unverifiedCount} unverified ${unverifiedCount === 1 ? 'payment' : 'payments'} totaling ${unverifiedAmount} ETH pending verification.
                                    </div>
                                </div>
                            `;
                            noticeContainer.style.display = 'block';
                        }
                    } else {
                        // Hide notice if no unverified payments
                        const noticeContainer = document.getElementById('unverifiedPaymentsNotice');
                        if (noticeContainer) {
                            noticeContainer.style.display = 'none';
                        }
                    }
                } catch (error) {
                    console.error('Error displaying unverified payments notice:', error);
                }
            }
            
            // Display wrong payment stats if available
            if (data.wrongPayments && data.wrongPaymentsAmount) {
                try {
                    const wrongCount = data.wrongPayments;
                    const wrongAmount = formatETHValue(data.wrongPaymentsAmount);
                    
                    if (wrongCount > 0) {
                        // Show wrong payment notice
                        const noticeContainer = document.getElementById('wrongPaymentsNotice');
                        if (noticeContainer) {
                            noticeContainer.innerHTML = `
                                <div class="alert alert-danger" role="alert">
                                    <div class="d-flex align-items-center">
                                        <i class="bx bx-error-circle me-2" style="font-size: 1.25rem;"></i>
                                        <div>
                                            <strong>Warning: Wrong Payments Detected</strong>
                                            <p class="mb-0">${wrongCount} payment${wrongCount !== 1 ? 's' : ''} totaling ${wrongAmount} ETH ${wrongCount !== 1 ? 'were' : 'was'} 
                                            sent to incorrect addresses. These funds cannot be automatically recovered.</p>
                                        </div>
                                    </div>
                                    <div class="mt-2">
                                        <button class="btn btn-sm btn-outline-danger" onclick="showWrongPaymentsList()">
                                            <i class="bx bx-list-ul me-1"></i> View Details
                                        </button>
                                        <button class="btn btn-sm btn-outline-danger" onclick="showWrongPaymentsHelp()">
                                            <i class="bx bx-help-circle me-1"></i> Help & Recovery Options
                                        </button>
                                    </div>
                                </div>
                            `;
                            noticeContainer.style.display = 'block';
                        }
                    } else {
                        // Hide notice if no wrong payments
                        const noticeContainer = document.getElementById('wrongPaymentsNotice');
                        if (noticeContainer) {
                            noticeContainer.style.display = 'none';
                        }
                    }
                } catch (error) {
                    console.error('Error displaying wrong payments notice:', error);
                }
            }
        }

        // Update transaction display (legacy function - now calls the separate functions)
        function updateTransactionDisplay(data) {
            if (!data) {
                console.error('No transaction data provided to updateTransactionDisplay');
                return;
            }
            
            // Display the transaction history
            if (data.transactions) {
                displayTransactionHistory(data.transactions);
            }
            
            // Update payment notices
            updatePaymentNotices(data);
        }

        // Get status badge class
        function getStatusClass(status) {
            // Handle undefined or null status
            if (!status) {
                return 'status-pending';
            }
            
            // Make sure status is a string
            const statusStr = String(status).toLowerCase();
            
            switch (statusStr) {
                case 'confirmed':
                case 'verified':
                    return 'status-confirmed';
                case 'pending':
                    return 'status-pending';
                case 'failed':
                    return 'status-failed';
                case 'unverified':
                    return 'status-warning';
                default:
                    return 'status-pending';
            }
        }

        // Check if there are funds available before proceeding with a release
        async function checkFundsAvailable() {
            try {
                // Get the latest balance from the server
                const response = await fetchWithAuth('/api/wallet-balance');
                
                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success === false) {
                    throw new Error(data.error || 'Unknown error fetching balance');
                }
                
                // Extract balance values - prefer totalBalance, fall back to balance
                let totalBalance = data.totalBalance || data.balance || "0";
                
                // Convert to a number in ETH units that we can work with
                let balanceValue;
                
                // Try to determine if balance is already in ETH format or in wei
                if (typeof totalBalance === 'string' && totalBalance.includes('.')) {
                    // Already in ETH format (decimal string)
                    balanceValue = parseFloat(totalBalance);
                } else {
                    // Likely in wei format - convert using web3.utils if available
                    try {
                        if (web3 && web3.utils && web3.utils.fromWei) {
                            balanceValue = parseFloat(web3.utils.fromWei(totalBalance.toString(), 'ether'));
                        } else {
                            // Manual conversion
                            balanceValue = Number(totalBalance) / 1e18;
                        }
                    } catch (conversionError) {
                        console.error('Error converting balance:', conversionError);
                        // Last resort - try to parse as a number (might be in ETH already)
                        balanceValue = parseFloat(totalBalance);
                    }
                }
                
                console.log('Total balance value:', totalBalance, 'Converted:', balanceValue);
                
                // Check for address details to determine if we have usable funds
                const addressDetails = data.addressDetails || {};
                let highestSingleAddressBalance = 0;
                let highestSingleAddress = null;
                let hasDistributedFunds = false;
                
                // Find the address with the highest balance
                if (Object.keys(addressDetails).length > 0) {
                    console.log('Checking individual address balances...');
                    
                    for (const [address, details] of Object.entries(addressDetails)) {
                        const addrBalance = parseFloat(details.rawBalance || details.balance || 0);
                        console.log(`Address ${address}: ${addrBalance} ETH`);
                        
                        if (addrBalance > highestSingleAddressBalance) {
                            highestSingleAddressBalance = addrBalance;
                            highestSingleAddress = address;
                        }
                    }
                    
                    // If highest balance is very low but total is higher, we have distributed funds
                    if (highestSingleAddressBalance < 0.001 && balanceValue > 0.001) {
                        hasDistributedFunds = true;
                    }
                    
                    console.log(`Highest balance address: ${highestSingleAddress} with ${highestSingleAddressBalance} ETH`);
                }
                
                // If balance is zero or too small to process (dust), return false
                if (isNaN(balanceValue) || balanceValue <= 0.00001) {
                    return {
                        available: false,
                        balance: 0,
                        reason: 'No funds available'
                    };
                }
                
                // If we have funds spread across multiple addresses but no single address has enough
                if (hasDistributedFunds && highestSingleAddressBalance < 0.001) {
                    return {
                        available: false,
                        balance: balanceValue,
                        distributedFunds: true,
                        highestSingleAddressBalance,
                        reason: 'Funds are spread across multiple addresses'
                    };
                }
                
                // Return balance is available with the amount
                return {
                    available: true,
                    balance: balanceValue,
                    originalBalance: totalBalance,
                    formattedBalance: formatETHValue(totalBalance),
                    highestSingleAddressBalance
                };
            } catch (error) {
                console.error('Error checking available funds:', error);
                throw error;
            }
        }

        // Release specified amount of funds
        async function releaseFunds() {
            const amountInput = document.getElementById('releaseAmount').value;
            if (!amountInput || parseFloat(amountInput) <= 0) {
                showToast('Please enter a valid amount', 'error');
                return;
            }

            // Show checking spinner
            const releaseBtn = document.querySelector('.action-button-primary');
            const originalText = releaseBtn.textContent;
            releaseBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Checking funds...';
            releaseBtn.disabled = true;

            try {
                // Check available funds from server
                const fundsCheck = await checkFundsAvailable();
                
                // Reset button while showing validation messages
                releaseBtn.innerHTML = originalText;
                releaseBtn.disabled = false;
                
                if (!fundsCheck.available) {
                    showToast('No funds available to release', 'error');
                    return;
                }
                
                const amount = parseFloat(amountInput);
                if (amount > fundsCheck.balance) {
                    showToast(`Insufficient funds. Available balance: ${fundsCheck.formattedBalance} ETH`, 'error');
                    return;
                }

                // Disable release buttons to prevent double-clicks
                const releaseButtons = document.querySelectorAll('.action-button');
                releaseButtons.forEach(btn => btn.disabled = true);
                
                // Show release in progress UI
                releaseBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Processing...';
                
                // Safely convert amount to wei
                let amountWei;
                try {
                    if (web3 && web3.utils && web3.utils.toWei) {
                        // Format amount to ensure proper string conversion (avoid scientific notation)
                        const formattedAmount = amount.toFixed(18).replace(/\.?0+$/, "");
                        amountWei = web3.utils.toWei(formattedAmount, 'ether');
                        console.log(`Converted ${formattedAmount} ETH to ${amountWei} wei using web3.utils`);
                    } else {
                        // Manual conversion as fallback
                        amountWei = (BigInt(Math.floor(amount * 1e18)) || BigInt(0)).toString();
                        console.log(`Converted ${amount} ETH to ${amountWei} wei manually`);
                    }
                } catch (conversionError) {
                    console.error('Error converting to wei:', conversionError);
                    showToast('Error converting amount to wei format', 'error');
                    // Reset button state
                    releaseBtn.innerHTML = originalText;
                    releaseButtons.forEach(btn => btn.disabled = false);
                    return;
                }
                
                console.log(`Releasing ${amount} ETH (${amountWei} wei)`);
                showToast('Initiating funds release...', 'info');
                
                // Make the request with hardcoded API key
                const response = await fetch('/api/release-funds', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': API_KEY
                    },
                    body: JSON.stringify({
                        amount: amount.toString() // Send as string to avoid precision issues
                    })
                });

                // Handle response
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `Server error: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.success) {
                    // Update UI to show success state
                    releaseBtn.innerHTML = '<i class="bx bx-check me-2"></i>Success';
                    releaseBtn.classList.add('bg-success');
                    
                    showToast(`Successfully initiated release of ${amount} ETH. Transaction is being processed on the blockchain.`, 'success');
                    document.getElementById('releaseAmount').value = '';
                    
                    // Create status tracker
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'alert alert-info mt-3';
                    statusDiv.innerHTML = `
                        <div class="d-flex align-items-center">
                            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                            <div>
                                <strong>Transaction in progress</strong><br>
                                <small>Releasing ${amount} ETH to merchant wallet. This may take a few minutes to complete.</small>
                                ${data.txHash ? `<br><small>Transaction: <a href="https://sepolia.etherscan.io/tx/${data.txHash}" target="_blank">${data.txHash.substring(0, 10)}...${data.txHash.substring(data.txHash.length - 6)}</a></small>` : ''}
                            </div>
                        </div>
                    `;
                    
                    // Insert status tracker above the buttons
                    const buttonContainer = releaseBtn.parentElement;
                    buttonContainer.parentElement.insertBefore(statusDiv, buttonContainer);
                    
                    // Refresh data after a short delay to allow transaction to be recorded
                    const refreshInterval = setInterval(() => {
                        refreshBalance(true);
                        refreshTransactionHistory(true);
                        
                        // Check if transaction appears in the history
                        const txHistoryRows = document.querySelectorAll('#transactionHistory tr');
                        let found = false;
                        txHistoryRows.forEach(row => {
                            if (row.textContent.includes(data.txHash)) {
                                found = true;
                                clearInterval(refreshInterval);
                                statusDiv.className = 'alert alert-success mt-3';
                                statusDiv.innerHTML = `
                                    <div class="d-flex align-items-center">
                                        <i class="bx bx-check-circle me-2" style="font-size: 1.5rem;"></i>
                                        <div>
                                            <strong>Funds released successfully!</strong><br>
                                            <small>${amount} ETH has been released to the merchant wallet.</small>
                                            ${data.txHash ? `<br><small>Transaction: <a href="https://sepolia.etherscan.io/tx/${data.txHash}" target="_blank">${data.txHash.substring(0, 10)}...${data.txHash.substring(data.txHash.length - 6)}</a></small>` : ''}
                                        </div>
                                    </div>
                                `;
                                
                                // Reset the button after success
                                setTimeout(() => {
                                    releaseBtn.innerHTML = originalText;
                                    releaseBtn.classList.remove('bg-success');
                                    releaseButtons.forEach(btn => btn.disabled = false);
                                    
                                    // Remove the status div after some time
                                    setTimeout(() => {
                                        statusDiv.remove();
                                    }, 10000);
                                }, 3000);
                            }
                        });
                        
                        // If we haven't found the transaction after 30 seconds, stop checking but show it's still processing
                        if (!found && Date.now() - now > 30000) {
                            clearInterval(refreshInterval);
                            statusDiv.className = 'alert alert-warning mt-3';
                            statusDiv.innerHTML = `
                                <div class="d-flex align-items-center">
                                    <i class="bx bx-time me-2" style="font-size: 1.5rem;"></i>
                                    <div>
                                        <strong>Transaction still processing</strong><br>
                                        <small>The transaction to release ${amount} ETH is still being processed on the blockchain. It may take a few more minutes to complete.</small>
                                        ${data.txHash ? `<br><small>Transaction: <a href="https://sepolia.etherscan.io/tx/${data.txHash}" target="_blank">${data.txHash.substring(0, 10)}...${data.txHash.substring(data.txHash.length - 6)}</a></small>` : ''}
                                    </div>
                                </div>
                            `;
                            
                            // Reset the button
                            releaseBtn.innerHTML = originalText;
                            releaseBtn.classList.remove('bg-success');
                            releaseButtons.forEach(btn => btn.disabled = false);
                        }
                    }, 5000);
                    
                    // Store the start time for the timeout check
                    const now = Date.now();
                } else {
                    throw new Error(data.error || 'Unknown error releasing funds');
                }
            } catch (error) {
                console.error('Failed to release funds:', error);
                showToast('Failed to release funds: ' + error.message, 'error');
                
                // Reset UI
                const releaseBtn = document.querySelector('.action-button-primary');
                releaseBtn.textContent = 'Release Specified Amount';
                document.querySelectorAll('.action-button').forEach(btn => btn.disabled = false);
            }
        }

        // Release all available funds
        async function releaseAllFunds() {
            // Show checking spinner
            const releaseBtn = document.querySelector('.action-button-outline');
            const originalText = releaseBtn.textContent;
            releaseBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Checking funds...';
            releaseBtn.disabled = true;
            
            try {
                // Check available funds from server
                const fundsCheck = await checkFundsAvailable();
                
                // Reset button while showing validation messages
                releaseBtn.innerHTML = originalText;
                releaseBtn.disabled = false;
                
                if (!fundsCheck.available) {
                    if (fundsCheck.distributedFunds) {
                        // Show specialized message for distributed funds
                        showToast(`Funds are distributed across multiple addresses. Total: ${formatETHValue(fundsCheck.balance)} ETH, but no single address has enough to cover gas costs.`, 'error');
                        
                        // Show detailed info modal about distributed funds
                        showDistributedFundsHelp(fundsCheck);
                    } else {
                        showToast('No funds available to release: ' + (fundsCheck.reason || 'Unknown reason'), 'error');
                    }
                    return;
                }
                
                if (!confirm(`Are you sure you want to release ${fundsCheck.formattedBalance} ETH to your merchant wallet?`)) {
                    return;
                }

                // Disable release buttons to prevent double-clicks
                const releaseButtons = document.querySelectorAll('.action-button');
                releaseButtons.forEach(btn => btn.disabled = true);
                
                // Show release in progress UI
                releaseBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Processing...';
                
                console.log('Releasing all available funds');
                showToast('Initiating full funds release...', 'info');
                
                // Make the request with hardcoded API key
                const response = await fetch('/api/release-all-funds', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': API_KEY
                    }
                });

                // Handle response
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `Server error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Update UI to show success state
                    releaseBtn.innerHTML = '<i class="bx bx-check me-2"></i>Success';
                    releaseBtn.classList.add('bg-success');
                    
                    // Format the amount if available
                    const amount = data.amount ? formatETHValue(data.amount) + ' ETH' : 'all available funds';
                    
                    showToast(`Successfully initiated release of ${amount}. Transaction is being processed on the blockchain.`, 'success');
                    
                    // Create status tracker
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'alert alert-info mt-3';
                    statusDiv.innerHTML = `
                        <div class="d-flex align-items-center">
                            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                            <div>
                                <strong>Transaction in progress</strong><br>
                                <small>Releasing ${amount} to merchant wallet. This may take a few minutes to complete.</small>
                                ${data.txHash ? `<br><small>Transaction: <a href="https://sepolia.etherscan.io/tx/${data.txHash}" target="_blank">${data.txHash.substring(0, 10)}...${data.txHash.substring(data.txHash.length - 6)}</a></small>` : ''}
                            </div>
                        </div>
                    `;
                    
                    // Insert status tracker above the buttons
                    const buttonContainer = releaseBtn.parentElement;
                    buttonContainer.parentElement.insertBefore(statusDiv, buttonContainer);
                    
                    // Refresh data after a short delay to allow transaction to be recorded
                    const refreshInterval = setInterval(() => {
                        refreshBalance(true);
                        refreshTransactionHistory(true);
                        
                        // Check if transaction appears in the history
                        const txHistoryRows = document.querySelectorAll('#transactionHistory tr');
                        let found = false;
                        txHistoryRows.forEach(row => {
                            if (data.txHash && row.textContent.includes(data.txHash)) {
                                found = true;
                                clearInterval(refreshInterval);
                                statusDiv.className = 'alert alert-success mt-3';
                                statusDiv.innerHTML = `
                                    <div class="d-flex align-items-center">
                                        <i class="bx bx-check-circle me-2" style="font-size: 1.5rem;"></i>
                                        <div>
                                            <strong>Funds released successfully!</strong><br>
                                            <small>${amount} has been released to the merchant wallet.</small>
                                            ${data.txHash ? `<br><small>Transaction: <a href="https://sepolia.etherscan.io/tx/${data.txHash}" target="_blank">${data.txHash.substring(0, 10)}...${data.txHash.substring(data.txHash.length - 6)}</a></small>` : ''}
                                        </div>
                                    </div>
                                `;
                                
                                // Reset the button after success
                                setTimeout(() => {
                                    releaseBtn.innerHTML = originalText;
                                    releaseBtn.classList.remove('bg-success');
                                    releaseButtons.forEach(btn => btn.disabled = false);
                                    
                                    // Remove the status div after some time
                                    setTimeout(() => {
                                        statusDiv.remove();
                                    }, 10000);
                                }, 3000);
                            }
                        });
                        
                        // If we haven't found the transaction after 30 seconds, stop checking but show it's still processing
                        if (!found && Date.now() - now > 30000) {
                            clearInterval(refreshInterval);
                            statusDiv.className = 'alert alert-warning mt-3';
                            statusDiv.innerHTML = `
                                <div class="d-flex align-items-center">
                                    <i class="bx bx-time me-2" style="font-size: 1.5rem;"></i>
                                    <div>
                                        <strong>Transaction still processing</strong><br>
                                        <small>The transaction to release ${amount} is still being processed on the blockchain. It may take a few more minutes to complete.</small>
                                        ${data.txHash ? `<br><small>Transaction: <a href="https://sepolia.etherscan.io/tx/${data.txHash}" target="_blank">${data.txHash.substring(0, 10)}...${data.txHash.substring(data.txHash.length - 6)}</a></small>` : ''}
                                    </div>
                                </div>
                            `;
                            
                            // Reset the button
                            releaseBtn.innerHTML = originalText;
                            releaseBtn.classList.remove('bg-success');
                            releaseButtons.forEach(btn => btn.disabled = false);
                        }
                    }, 5000);
                    
                    // Store the start time for the timeout check
                    const now = Date.now();
                } else {
                    throw new Error(data.error || 'Unknown error releasing funds');
                }
            } catch (error) {
                console.error('Failed to release all funds:', error);
                showToast('Failed to release all funds: ' + error.message, 'error');
                
                // Reset UI
                const releaseBtn = document.querySelector('.action-button-outline');
                releaseBtn.textContent = 'Release All Funds';
                document.querySelectorAll('.action-button').forEach(btn => btn.disabled = false);
            }
        }

        // Show distributed funds help modal
        function showDistributedFundsHelp(fundsCheck) {
            // Create a modal element
            const modalHTML = `
                <div class="modal fade" id="distributedFundsModal" tabindex="-1" aria-hidden="true">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Funds Distribution Issue</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <div class="alert alert-warning">
                                    <h6><i class="bx bx-info-circle me-2"></i>Distributed Funds Detected</h6>
                                    <p>Your funds are spread across multiple HD wallet addresses, making it difficult to release them in a single transaction.</p>
                                </div>
                                
                                <h6>Current Balance Status:</h6>
                                <ul>
                                    <li>Total balance across all addresses: <strong>${formatETHValue(fundsCheck.balance)} ETH</strong></li>
                                    <li>Highest single address balance: <strong>${formatETHValue(fundsCheck.highestSingleAddressBalance)} ETH</strong></li>
                                </ul>
                                
                                <h6>Why is this happening?</h6>
                                <p>Each payment to your store creates a new HD wallet address. When customers make small payments, the funds get distributed across many addresses, none of which may have enough to cover the transaction fees to release the funds.</p>
                                
                                <h6>Options to resolve this:</h6>
                                <ol>
                                    <li><strong>Wait for more payments</strong> to accumulate in a single address.</li>
                                    <li><strong>Send a small amount of ETH</strong> to your wallet to consolidate funds (approximately 0.005 ETH should be enough).</li>
                                </ol>
                                
                                <div class="alert alert-info mt-3">
                                    <strong>Technical note:</strong> Each transaction on Ethereum requires gas fees. When funds are spread across multiple addresses, each address needs enough ETH to cover both the transfer amount and gas fees.
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to the document if it doesn't exist
            if (!document.getElementById('distributedFundsModal')) {
                const modalContainer = document.createElement('div');
                modalContainer.innerHTML = modalHTML;
                document.body.appendChild(modalContainer.firstChild);
            } else {
                // Update modal content if it exists
                document.getElementById('distributedFundsModal').outerHTML = modalHTML;
            }
            
            // Initialize and show the modal
            const helpModal = new bootstrap.Modal(document.getElementById('distributedFundsModal'));
            helpModal.show();
        }

        // Copy to clipboard function
        async function copyToClipboard(text, button) {
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.innerHTML;
                button.innerHTML = '<i class="bx bx-check"></i>';
                setTimeout(() => {
                    button.innerHTML = originalText;
                }, 2000);
                showToast('Copied to clipboard', 'success');
            } catch (err) {
                console.error('Failed to copy:', err);
                showToast('Failed to copy to clipboard', 'error');
            }
        }

        // Show toast notification - Bootstrap 5 version
        function showToast(message, type = 'success') {
            console.log(`TOAST: [${type}] ${message}`);
            
            // Get toast elements
            const toastEl = document.getElementById('toast');
            const toastContent = document.getElementById('toastContent');
            const toastIcon = document.getElementById('toastIcon');
            const toastTitle = document.getElementById('toastTitle');
            
            if (!toastEl || !toastContent) {
                console.error('Toast elements not found!', { 
                    toastEl: !!toastEl, 
                    toastContent: !!toastContent 
                });
                return;
            }
            
            // Set content
            toastContent.textContent = message;
            
            // Set icon and title based on type
            switch (type) {
                case 'success':
                    toastIcon.className = 'bx bx-check-circle text-success';
                    toastTitle.textContent = 'Success';
                    toastTitle.className = 'me-auto text-success';
                    break;
                case 'error':
                    toastIcon.className = 'bx bx-error-circle text-danger';
                    toastTitle.textContent = 'Error';
                    toastTitle.className = 'me-auto text-danger';
                    break;
                case 'warning':
                    toastIcon.className = 'bx bx-error text-warning';
                    toastTitle.textContent = 'Warning';
                    toastTitle.className = 'me-auto text-warning';
                    break;
                case 'info':
                    toastIcon.className = 'bx bx-info-circle text-info';
                    toastTitle.textContent = 'Information';
                    toastTitle.className = 'me-auto text-info';
                    break;
                default:
                    toastIcon.className = 'bx bx-bell text-primary';
                    toastTitle.textContent = 'Notification';
                    toastTitle.className = 'me-auto text-primary';
            }
            
            // Get Bootstrap toast instance or create one
            let bsToast = bootstrap.Toast.getInstance(toastEl);
            
            if (!bsToast) {
                console.log('Creating new Bootstrap Toast instance');
                bsToast = new bootstrap.Toast(toastEl, {
                    animation: true,
                    autohide: true,
                    delay: 5000
                });
            }
            
            // Show the toast
            try {
                bsToast.show();
                console.log('Toast shown successfully');
            } catch (error) {
                console.error('Error showing toast:', error);
                
                // Fallback to manual display if Bootstrap toast fails
                toastEl.style.display = 'block';
                setTimeout(() => {
                    toastEl.style.display = 'none';
                }, 5000);
            }
        }

        // Add this function to show details of wrong payments
        function showWrongPaymentsList() {
            // We'll use transaction cache if available
            if (!transactionCache || !transactionCache.transactions) {
                showToast('Loading wrong payment details...', 'info');
                // Call refreshTransactionHistory with force refresh
                refreshTransactionHistory(true);
                // Use setTimeout to allow refresh to complete
                setTimeout(() => {
                    if (transactionCache && transactionCache.transactions) {
                        createWrongPaymentsListModal(transactionCache.transactions);
                    } else {
                        showToast('Could not load transaction data', 'error');
                    }
                }, 1500); // Wait 1.5 seconds for data to load
            } else {
                createWrongPaymentsListModal(transactionCache.transactions);
            }
        }

        // Create and show modal with wrong payments list
        function createWrongPaymentsListModal(transactions) {
            // Filter out wrong payments
            const wrongPayments = transactions.filter(tx => 
                tx.isWrongPayment === true || 
                tx.wrongPayment === true || 
                tx.status === 'wrong'
            );
            
            if (wrongPayments.length === 0) {
                showToast('No wrong payments found', 'info');
                return;
            }
            
            // Create table rows for each wrong payment
            const paymentRows = wrongPayments.map(payment => {
                // Format date
                let dateDisplay = 'Unknown date';
                if (payment.timestamp) {
                    try {
                        const txDate = new Date(payment.timestamp);
                        if (!isNaN(txDate.getTime())) {
                            dateDisplay = txDate.toLocaleString();
                        }
                    } catch (dateError) {
                        console.warn('Error formatting date:', dateError);
                    }
                }
                
                // Format amount
                const amount = formatETHValue(payment.amount);
                
                // Get address
                const address = payment.address || 'Unknown';
                
                return `
                    <tr>
                        <td>${dateDisplay}</td>
                        <td>${amount} ETH</td>
                        <td>
                            <div class="d-flex align-items-center">
                                <span class="text-break">${address}</span>
                                <button class="btn btn-sm ms-2 copy-button" onclick="copyToClipboard('${address}', this)">
                                    <i class="bx bx-copy"></i>
                                </button>
                            </div>
                            <div class="wrong-payment-details mt-1">
                                <span class="wrong-payment-tag">Wrong Address</span>
                                <small>This address is not part of your HD wallet - funds cannot be automatically recovered</small>
                            </div>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-secondary" onclick="openAddressInExplorer('${address}')">
                                <i class="bx bx-link-external me-1"></i> View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Create modal with wrong payments data
            const modalHTML = `
                <div class="modal fade" id="wrongPaymentsListModal" tabindex="-1" aria-hidden="true">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Wrong Payments Details</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <div class="alert alert-danger">
                                    <i class="bx bx-error-circle me-2"></i>
                                    <span>These payments were sent to addresses outside your HD wallet structure and cannot be recovered automatically.</span>
                                </div>
                                
                                <div class="table-responsive">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Date</th>
                                                <th>Amount</th>
                                                <th>Address</th>
                                                <th>Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${paymentRows}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                <button type="button" class="btn btn-danger" onclick="showWrongPaymentsHelp()">Recovery Options</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to the document if it doesn't exist
            if (document.getElementById('wrongPaymentsListModal')) {
                document.getElementById('wrongPaymentsListModal').remove();
            }
            
            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer.firstChild);
            
            // Initialize and show the modal
            const wrongPaymentsListModal = new bootstrap.Modal(document.getElementById('wrongPaymentsListModal'));
            wrongPaymentsListModal.show();
        }

        // Function to open address in block explorer
        function openAddressInExplorer(address) {
            if (!address) return;
            
            const explorerUrl = `https://sepolia.etherscan.io/address/${address}`;
            window.open(explorerUrl, '_blank');
        }

        // Add this function to show help about wrong payments
        function showWrongPaymentsHelp() {
            // Create a modal element
            const modalHTML = `
                <div class="modal fade" id="wrongPaymentsModal" tabindex="-1" aria-hidden="true">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Wrong Payments Help</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <div class="alert alert-danger mb-4">
                                    <i class="bx bx-error-circle me-2"></i>
                                    <strong>Important:</strong> Funds sent to wrong addresses cannot be automatically recovered by your merchant system.
                                </div>
                                
                                <h6><i class="bx bx-question-mark me-2"></i>What are wrong payments?</h6>
                                <p>Wrong payments occur when customers send funds to addresses that aren't part of your HD wallet structure. These could be:</p>
                                <ul>
                                    <li>Payments to old addresses that are no longer monitored</li>
                                    <li>Payments to addresses with typos or mistakes</li>
                                    <li>Payments sent to the wrong blockchain network</li>
                                    <li>Payments to addresses that don't belong to your payment gateway</li>
                                </ul>
                                
                                <h6 class="mt-4"><i class="bx bx-lock me-2"></i>Why can't these be recovered automatically?</h6>
                                <p>Since these addresses aren't derived from your HD wallet, your system doesn't have the private keys needed to control these funds. Without the private key, no one can move the funds from that address.</p>
                                
                                <h6 class="mt-4"><i class="bx bx-help-circle me-2"></i>Recovery options</h6>
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <h6 class="card-title"><i class="bx bx-user me-2"></i>If you can identify the sender:</h6>
                                        <p>Contact the customer and request they initiate a new transaction to the correct address. The incorrect transaction cannot be reversed, but they can send a new payment.</p>
                                    </div>
                                </div>
                                
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <h6 class="card-title"><i class="bx bx-key me-2"></i>If you have the private key to the wrong address:</h6>
                                        <p>If you happen to have access to the private key (perhaps it's an old address you used to control), you can manually transfer the funds using a wallet like MetaMask.</p>
                                        <p class="text-danger">Never share private keys with anyone, including customer support.</p>
                                    </div>
                                </div>
                                
                                <div class="card">
                                    <div class="card-body">
                                        <h6 class="card-title"><i class="bx bx-error me-2"></i>If recovery isn't possible:</h6>
                                        <p>Unfortunately, in most cases where the wrong address doesn't belong to you, the funds will remain locked indefinitely unless the owner of that address transfers them.</p>
                                    </div>
                                </div>
                                
                                <h6 class="mt-4"><i class="bx bx-shield me-2"></i>Prevention</h6>
                                <p>To prevent wrong payments in the future:</p>
                                <ul>
                                    <li>Always provide a QR code for payments when possible</li>
                                    <li>Keep payment addresses active for a reasonable time period</li>
                                    <li>Consider implementing address validation in your customer interface</li>
                                    <li>Use ENS domains or other human-readable addresses when possible</li>
                                </ul>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-outline-danger" onclick="showWrongPaymentsList()">View Wrong Payments</button>
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to the document if it doesn't exist
            if (document.getElementById('wrongPaymentsModal')) {
                document.getElementById('wrongPaymentsModal').remove();
            }
            
            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer.firstChild);
            
            // Initialize and show the modal
            const wrongPaymentsModal = new bootstrap.Modal(document.getElementById('wrongPaymentsModal'));
            wrongPaymentsModal.show();
        }

        // Function to verify a transaction status by calling the verification API
        async function verifyTransaction(txHash) {
            if (!txHash) {
                console.error('verifyTransaction called with no txHash');
                showToast('No transaction hash provided', 'error');
                return;
            }
            
            console.log(`Starting verification for transaction: ${txHash}`);
            
            // Create a status indicator in the UI for this transaction
            const txRows = document.querySelectorAll('#transactionHistory tr');
            let txRow = null;
            
            // Find the row containing this transaction hash
            txRows.forEach(row => {
                if (row.textContent.includes(txHash)) {
                    txRow = row;
                }
            });
            
            if (txRow) {
                // Add a verification status indicator to the row
                const statusCell = txRow.querySelector('td:nth-child(4)');
                if (statusCell) {
                    const originalContent = statusCell.innerHTML;
                    statusCell.innerHTML = `
                        <div class="d-flex align-items-center">
                            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                            <span>Verifying...</span>
                        </div>
                    `;
                    
                    // Restore original content on error or after 15 seconds (timeout)
                    const restoreContent = () => {
                        if (statusCell.querySelector('.spinner-border')) {
                            console.log(`Restoring original status display for ${txHash}`);
                            statusCell.innerHTML = originalContent;
                        }
                    };
                    
                    // Safety timeout to prevent spinner showing forever if something fails
                    setTimeout(restoreContent, 15000);
                }
            }
            
            try {
                // Show verification in progress
                showToast(`Verifying transaction ${txHash.substring(0, 8)}...`, 'info');
                
                console.log(`Sending verification request to API for ${txHash}`);
                
                // Log API request details
                const requestDetails = {
                    url: '/api/verify-transaction',
                    method: 'POST',
                    body: { txHash }
                };
                console.log('API Request:', JSON.stringify(requestDetails));
                
                // Call the verification API with detailed error logging
                const response = await fetchWithAuth('/api/verify-transaction', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ txHash })
                });
                
                console.log(`API response status: ${response.status}`);
                
                // Get a clone of the response to read the body as text
                const clonedResponse = response.clone();
                const responseText = await clonedResponse.text();
                
                console.log(`Raw API response: ${responseText}`);
                
                // Parse the response text to JSON
                let data;
                try {
                    data = JSON.parse(responseText);
                    console.log('Parsed verification data:', data);
                } catch (parseError) {
                    console.error('Error parsing API response:', parseError);
                    throw new Error(`Invalid response format: ${responseText}`);
                }
                
                if (!response.ok) {
                    let errorMessage = `Server responded with status: ${response.status}`;
                    if (data && data.error) {
                        errorMessage = data.error;
                    }
                    console.error(`Verification API error: ${errorMessage}`);
                    throw new Error(errorMessage);
                }
                
                if (data.success === false) {
                    console.error(`Verification failed with error: ${data.error || 'Unknown error'}`);
                    throw new Error(data.error || 'Verification failed');
                }
                
                console.log('Verification complete. Result:', data);
                
                // Update UI based on verification result
                if (txRow) {
                    const statusCell = txRow.querySelector('td:nth-child(4)');
                    if (statusCell) {
                        let statusClass = getStatusClass(data.status);
                        let statusText = data.status.charAt(0).toUpperCase() + data.status.slice(1);
                        
                        statusCell.innerHTML = `
                            <span class="status-badge ${statusClass}">
                                ${statusText}
                            </span>
                        `;
                    }
                }
                
                // Show success or failure toast based on verification result
                if (data.status === 'confirmed') {
                    showToast('Transaction verified successfully!', 'success');
                } else if (data.status === 'failed') {
                    showToast('Transaction failed on the blockchain', 'error');
                } else if (data.status === 'pending') {
                    showToast('Transaction is still pending on the blockchain', 'warning');
                } else {
                    showToast(`Transaction status: ${data.status}`, 'info');
                }
                
                // Refresh the transaction history to reflect the updated status
                console.log('Scheduling refresh of transaction history');
                setTimeout(() => refreshTransactionHistory(true), 2000);
                
            } catch (error) {
                console.error('Error verifying transaction:', error);
                
                // Restore original row content if there was an error
                if (txRow) {
                    const statusCell = txRow.querySelector('td:nth-child(4)');
                    if (statusCell && statusCell.querySelector('.spinner-border')) {
                        statusCell.innerHTML = `
                            <span class="status-badge status-failed">
                                Verification Failed
                            </span>
                        `;
                    }
                }
                
                showToast(`Verification failed: ${error.message}`, 'error');
            }
        }

        // Function to verify all pending transactions
        async function verifyAllTransactions() {
            if (!transactionCache || !transactionCache.transactions || !Array.isArray(transactionCache.transactions)) {
                showToast('No transaction data available', 'error');
                return;
            }
            
            try {
                showToast('Checking for transactions to verify...', 'info');
                
                // Find all payment transactions that are not confirmed or verified
                verifyPendingTransactions(transactionCache.transactions);
            } catch (error) {
                console.error('Error verifying all transactions:', error);
                showToast(`Error: ${error.message}`, 'error');
            }
        }
        
        // Function to verify pending transactions
        async function verifyPendingTransactions(transactions) {
            if (!transactions || !Array.isArray(transactions)) {
                console.error('verifyPendingTransactions called with invalid transactions data:', transactions);
                return;
            }
            
            try {
                console.log('Starting verification of pending transactions');
                console.log('Transaction data:', JSON.stringify(transactions.map(tx => ({
                    txHash: tx.txHash || tx.hash,
                    type: tx.type,
                    status: tx.status
                }))));
                
                // Filter for pending payment transactions with a txHash
                const pendingTxs = transactions.filter(tx => 
                    tx && 
                    tx.type === 'payment' && 
                    (tx.status === 'pending' || tx.status === 'unverified') &&
                    (tx.txHash || tx.hash) && 
                    (tx.txHash !== 'unknown' || tx.hash !== 'unknown')
                );
                
                console.log(`Found ${pendingTxs.length} pending transactions to verify`);
                
                if (pendingTxs.length === 0) {
                    showToast('No pending transactions to verify', 'info');
                    return;
                }
                
                // Create or update verification progress modal
                let progressModal = document.getElementById('verificationProgressModal');
                if (!progressModal) {
                    // Create the modal if it doesn't exist
                    const modalHtml = `
                        <div class="modal fade" id="verificationProgressModal" tabindex="-1" aria-hidden="true">
                            <div class="modal-dialog">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title">Verifying Transactions</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body">
                                        <div id="verificationProgressText">Starting transaction verification...</div>
                                        <div class="progress mt-3">
                                            <div id="verificationProgressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                                        </div>
                                        <div id="verificationResults" class="mt-3">
                                            <div class="text-muted">Waiting for results...</div>
                                        </div>
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Add the modal to the document
                    const modalContainer = document.createElement('div');
                    modalContainer.innerHTML = modalHtml;
                    document.body.appendChild(modalContainer);
                    
                    // Get the modal reference
                    progressModal = document.getElementById('verificationProgressModal');
                }
                
                // Initialize the modal
                const bsProgressModal = new bootstrap.Modal(progressModal);
                bsProgressModal.show();
                
                const progressBar = document.getElementById('verificationProgressBar');
                const progressText = document.getElementById('verificationProgressText');
                const resultsDiv = document.getElementById('verificationResults');
                
                if (progressBar && progressText && resultsDiv) {
                    progressBar.style.width = '0%';
                    progressText.textContent = `Starting verification of ${pendingTxs.length} transaction(s)...`;
                    resultsDiv.innerHTML = '<div class="text-muted">Waiting for results...</div>';
                }
                
                showToast(`Verifying ${pendingTxs.length} transaction(s)...`, 'info');
                
                // Verify each transaction
                let verifiedCount = 0;
                let failedCount = 0;
                let stillPendingCount = 0;
                const results = [];
                
                for (let i = 0; i < pendingTxs.length; i++) {
                    const tx = pendingTxs[i];
                    const txHash = tx.txHash || tx.hash;
                    const progress = Math.round(((i + 1) / pendingTxs.length) * 100);
                    
                    try {
                        // Update progress
                        if (progressBar && progressText) {
                            progressBar.style.width = `${progress}%`;
                            progressText.textContent = `Verifying transaction ${i + 1} of ${pendingTxs.length}: ${txHash.substring(0, 8)}...`;
                        }
                        
                        console.log(`Verifying transaction ${i + 1}/${pendingTxs.length}: ${txHash}`);
                        
                        // Call the verification API
                        const response = await fetchWithAuth('/api/verify-transaction', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ txHash })
                        });
                        
                        // Log response status
                        console.log(`API response for ${txHash}: Status ${response.status}`);
                        
                        const responseText = await response.text();
                        console.log(`Raw API response for ${txHash}: ${responseText}`);
                        
                        let data;
                        try {
                            data = JSON.parse(responseText);
                        } catch (parseError) {
                            console.error(`Error parsing response for ${txHash}:`, parseError);
                            throw new Error(`Invalid response format: ${responseText}`);
                        }
                        
                        if (response.ok && data.success) {
                            console.log(`Transaction ${txHash} verified: ${data.status}`);
                            
                            if (data.status === 'confirmed') {
                                verifiedCount++;
                                results.push({
                                    txHash, 
                                    status: 'confirmed',
                                    statusText: 'Confirmed',
                                    className: 'text-success'
                                });
                            } else if (data.status === 'failed') {
                                failedCount++;
                                results.push({
                                    txHash, 
                                    status: 'failed',
                                    statusText: 'Failed',
                                    className: 'text-danger'
                                });
                            } else if (data.status === 'pending') {
                                stillPendingCount++;
                                results.push({
                                    txHash, 
                                    status: 'pending',
                                    statusText: 'Still Pending',
                                    className: 'text-warning'
                                });
                            } else {
                                results.push({
                                    txHash, 
                                    status: data.status,
                                    statusText: data.status.charAt(0).toUpperCase() + data.status.slice(1),
                                    className: 'text-info'
                                });
                            }
                        } else {
                            failedCount++;
                            const errorMessage = data.error || `API Error (${response.status})`;
                            console.error(`Verification API error for ${txHash}:`, errorMessage);
                            
                            results.push({
                                txHash, 
                                status: 'error',
                                statusText: 'Error',
                                message: errorMessage,
                                className: 'text-danger'
                            });
                        }
                    } catch (txError) {
                        failedCount++;
                        console.error(`Error verifying transaction ${txHash}:`, txError);
                        
                        results.push({
                            txHash, 
                            status: 'error',
                            statusText: 'Error',
                            message: txError.message,
                            className: 'text-danger'
                        });
                    }
                    
                    // Update results in modal
                    if (resultsDiv) {
                        const resultsList = results.map(r => `
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <div>
                                    <span class="${r.className} me-2">●</span>
                                    ${r.txHash.substring(0, 8)}...${r.txHash.substring(r.txHash.length - 6)}
                                </div>
                                <div class="${r.className}">
                                    ${r.statusText}
                                    ${r.message ? `<small class="d-block text-muted">${r.message}</small>` : ''}
                                </div>
                            </div>
                        `).join('');
                        
                        resultsDiv.innerHTML = resultsList;
                    }
                    
                    // Small delay to avoid overwhelming the server
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Update final progress
                if (progressBar && progressText) {
                    progressBar.style.width = '100%';
                    progressText.textContent = 'Verification complete';
                }
                
                console.log('Verification results:', {
                    verifiedCount,
                    failedCount,
                    stillPendingCount,
                    total: pendingTxs.length
                });
                
                // Refresh transaction history to show updated status
                await refreshTransactionHistory(true, false);
                
                // Show results modal and toast notification
                if (verifiedCount > 0) {
                    showToast(`Successfully verified ${verifiedCount} of ${pendingTxs.length} transaction(s)`, 'success');
                } else if (stillPendingCount > 0) {
                    showToast(`${stillPendingCount} transaction(s) still pending on blockchain`, 'warning');
                } else {
                    showToast('No transactions were successfully verified', 'warning');
                }
                
            } catch (error) {
                console.error('Error in verifyPendingTransactions:', error);
                showToast(`Error verifying transactions: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>
